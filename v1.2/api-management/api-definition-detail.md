+++
draft = false
title = "API Definition Objects - In Depth"
date = 2014-07-29T10:56:22Z
[menu.sidebar_v1_2]
    parent = "management"
+++

Tyk handles APIs through files / objects called Definitions, these either sit in the `/etc/tyk/apps` directory or in a MongoDB collection.

An API Definition has many switches that change the way an incoming request is handled. It is possible to set too many options in a defintiton which can lead to unexpected behaviour.

With this in mind, we have split this section into the most common settings that are used together.

## Common elements

#### `id`
This is only used in the MongoDB context and bears no actual relation to the identity of the API

#### `name`
Human readable name of the API, is used for identification purposes but does not act as an index.

#### `api_id`
The identifier for the API, this should be unique, but can actually be any kind of string. for single-instance setups this can probably be set to 1. It is recommended to make this a UUID.

The api_id is used when querying the Tyk REST API for configuration details.

#### `org_id`
This is an identifier that can be set to indicate ownership of an API key or of an individual API. 

If the the Org ID is set (recommended), it is prepended to any Keys generated by Tyk - this enables lookups by prefixes from redis of keys that are in the system.

#### `active`
If set to `false` means that on start, restart or reload the API will be ignored and all paths and routes for that API will cease to be proxied. Any keys assigned ot it will still exist, though they will not be let through for that particular API.

#### `session_lifetime`

The session lifetime will override the expiry date if it has been set on a key (in seconds). for example, if a key has been created that never expires, then it will remain in the
session cache forever unless manually deleted. If a re-auth needs to be forced or a default expiry needs to be applied to all keys, then use this feature to set the session
expiry for an entire API.

## Authentication type flags
By default, Tyk will revert to a simple authentication token scheme unless these flags and their metadata are set (setting all of these to false will enable standard token mode).

This scheme basically means that you could send an authentication parameter and it's value (the api key) along with the request and Tyk will attach it to a session, just like a bearer token in OAuth or a session key in cookie-based setups.

However Tyk supports many more methods, and these can be set by enabling these flags (and their associated metadata)

### `use_keyless`

This will switch off all key checking and open the API definition up, some analytics will still be recorded, but rate-limiting, quotas and security policies will not be possible (there is no session to attach requests to).

this is a good setting for checking if Tyk works and is proxying traffic correctly.

*This method has no additional metadata settings*

### `use_basic_auth`

This method will enable basic auth as specified by the HTTP spec, an API with this flag set will request for a username and password and require a standard base64 Authentication header to be let thorugh.

Keys cannot be generated by tyk for this method and need to use the `/tyk/keys/add` method with the `basic_auth_data` metadata set in the keys session configuration (see [Basic Authentication](/access-control/basic-auth) and the overview of the Session Object in this use case under [Key Management](/rest-api/api-key-management)).

### `enable_signature_checking` a.k.a HMAC signing

If this option is set to `true`, Tyk will attempt to implement the HMAC singing standard as proposed in the [HTTP Signatures Spec](https://web-payments.org/specs/ED/http-signatures/2014-02-01/#page-3). In particular the structure of the Authorisation header and the encoding method need to be taken into account.

This method will use a session key to identify a user and a user secret that should be used by the client to sign each request's `date` header.

This method will also introduce clock skew checks, requests outside of 300ms of the system time will be rejected.

This method is not recommended for Single-Page-Webapps or Mobile apps due to the fact that secrets need to be distributed. 

### `use_oauth2`

Tyk attempts to implement a semi-seamless OAuth2 flow. Given the nature of OAuth2's three-party system, it is difficult to implement as a proxy without significantly compromising security or usability. 

Enabling this option will cause Tyk to add OAuth2-standard endpoints to the API for `/authorize` and `/token`, these will supersede any other requests to your proxied system in order to enable the flow.

Please see the [OAuth2 Flow](/access-control/oauth2) section for a comprehensive discussion of how to integrate with Tyk.

#### `oauth_meta.allowed_access_types`

Should be a string array of OAuth access options, types can be:

- `authorization_code` - client has an authorisation code to request a new access token
- `refresh_token` - client can use a refresh token to refresh expired bearer access token

**Note**: If using auth codes and refresh tokens, Tyk needs to notify your webapp of newly issued keys - it does this via web hook, please see the section on `notifications`.

#### `oauth_meta.allowed_authorize_types`

Should be a string array of OAuth authorisation types - options that are supported are:

- `code` - Client can request an authorization code which can be used to request an access code via a server request (traditionally reserved for server-side apps)
- `token` - Client can request an access token directly, this will not enable refresh tokens and all tokens have a 12 hour validity. Recommended for mobile apps and single-page webapps.

#### `oauth_meta.auth_login_redirect`

The Tyk OAuth flow has a dummy (intercept) `/authorize` endpoint which basically redirects the user to your login and authentication page, it will also send along all OAuth data as part of the request (so as to mimic a regular app flow).

This is the URL that the user will be sent to (via POST).

**Note**: This interface method is only supported by modern browsers that respect a [307 redirect](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection) (retaining method and data), and varies between browsers.

### `notifications`

When Tyk implements an OAuth2 flow, because it will handle access requests on your behalf once auth codes have been issued, it will need to notify your system that these have occured.

It will POST key data to the URL set in these options to ensure that your system is synchronised with Tyk.

#### `notifications.shared_secret`

POSTED data to your service will use this shared secret as an authorisation header, this is to ensure that messages being received are from Tyk and not from another system.

#### `notifications.oauth_on_keychange_url`

The URL that wil be sent the updated information - the URL will be polled up to 3 times if there is a communications failure. On a `200 OK` response it stops.

### `auth`

The auth section handles the standard Tyk authentication method, and if none of the above are set, will be the method used to authenticate requests.

#### `auth.auth_header_name`

The header carrying the authentication token. Currently parameter-based authentication token passing is not supported.

## Versioning and Endpoint Handling

Tyk lets you version your API and apply access policies to versions, for example, if you have an API v1 that has a /widgets endpoint that is deprecated in v2, you can blacklist that endpoint so that requests to it are stopped before they hit your system.

In the same vein, you can white-list and ignore paths completely.

Version data can be transferred as either a header key or as a query parameter in all HTTP methods.

### `definition`

This section handles information related to where to look for the version key

#### `definition.location`

Can either be:

- `header`: Tyk will look for the version information in a header field (e.g. api-version: 1.2.3)
- `url-param` Tyk will check form and request parameters for a key matching the `definition.key` value.

#### `definition.key`

The name of the key to check for versioning information.

### `version_data`

Information relating to your actual version are stored here, if you do not wish to use versioning, use the `not_versioned` option and set up an entry called `Default` (see below).

### `version_data.not_versioned`

If set to `true` Tyk will skip version checking, you can still apply blacklist and white-list information to your API by specifying a `Default` version within the `versions` map

### `version_data.versions`

This is a keyed JSON object, in the form of:

	{
		"version-1": {
			"name": "version-1",
			"expires": "",
			"paths": {
				"ignored": [],
				"white_list": [],
				"black_list": []
			}
		}
	}

Each version of your API should be defined here with a unique name, this name is what will be matched by `defintition.key`. Once Tyk has identified the API to load, and has 
allowed the access key through, it will check the access token's session data for access permissions. If it finds none, it will let the token through, however if there are 
permissions and versions defined, it will be strict in *only* allowing access to that version. For more information about handling access control, please see the 
[access control](/quotas-limits-security/access-control) section.


#### `version_data.{version-name}.expires`

The expires header, if set, will deprecate access to the API after the time specified. The entry here takes the form of: `"YYYY-MM-YY HH:MM"`. If this is not set the version will never expire.

#### `version_data.{version-name}.ignored`

This string array can define any paths (endpoints) in your API that should be ignored by Tyk, for example login, signup 
or any non-authenticated actions users can take. Specify these URL's here in the form of

    [
        "/user/login",
        "/user/signup"
    ]

Similar to other routers, matching is done on a first-come-first-served basis, ensure that specific paths are higher up the list than generic ones.

*Note:* It is possible to ignore non-generic paths using standard REST documentation markup, e.g. `/users/{user_id}/` will ignore `/users/12345/` and `/users/jively`, this is handy for cases where an entire sub-branch of a resource should be ignored (though each wildcard must be specified individually) Parameter names are arbitrary, and should be for reference only.

#### `version_data.{version-name}.white_list`

A string array of paths to white-list in your API, this is an explicit list of paths that are allowed access, any other endpoints, except those specified in 
`ignored_paths` will be refused access. Use this to enforce highly-specific access rules.

**Note:** White listing paths is exclusive, so black listed paths will not take effect.

#### `version_data.{version-name}.black_list`

The opposite of `white_list`, this will essentially block access to certain endpoints, this can be very handy if you are moving from a v1 to a v2 and have deprecated a path, simply define the deprecated 
path in the list and requests to it ith the new version header will be refused.

## `proxy`

The proxy section outlines the actual API proxying functionality, here you can define where Tyk should listen, and where Tyk should proxy traffic to.

### `proxy.listen_path`

The path to listen on, e.g. `/api` or `/`, any requests coming into the host, on the port that Tyk is configured to run on, that go to this path will have the rules 
defined in the API Definition applied. Versioning assumes that different versions of an API will live on the same URL structure. If you are using URL-based versioning 
(e.g. `/v1/function`, `/v2/function/` then it is recommended to set up a separate non-versioned Definition for each version as they are essentially separate APIs.

Proxied requests are literal, no re-writing takes place, fo example, if a request is sent to the listen path of: `/listen-path/widgets/new` and the URL to proxy to is
`http://your.api.com/api/` then the *actual* request that will land at your service will be: `http://your.api.com/api/listen-path/widgets/new`.

this behaviour can be circumvented so that the `listen_path` is stripped from the outgoing request. See the section on `strip_listen_path` below.

### `proxy.target_url`

This defines the target URL that the request should be proxied to if it passes all checks in Tyk.

### `proxy.strip_listen_path`

By setting this to `true`, Tyk will attempt to replace the listen_path in the outgoing request with an empty string - this means that in the above scenario where 
`/listen-path/widgets/new` and the URL to proxy to is `http://your.api.com/api/` becomes `http://your.api.com/api/listen-path/widgets/new`, actually
changes the outgoing request to be: `http://your.api.com/api/widgets/new`. 

## IP White-listing (Middleware)

### `enable_ip_whitelisting`

If set to `true`, only requests coming from the explicit list of IP addresses (`allowed_ips`) are allowed through.

## `allowed_ips`

A list of strings that defines the IP addresses that are allowed access via Tyk. This list is explicit and wildcareds are currently not supported. e.g.:

    ...
    "enable_ip_whitelisting": true,
    "allowed_ips": ["12.12.12.12", "12.12.12.13", "12.12.12.14"]
    ...

## Batch Requests (New)

Tyk now supports request batching, so a client only makes a single request to the API but gets a compound response object back. 

This is especially handy if clients have complex requests that hav multiple synchronous dependencies and do not wish to have the entire request / response cycle 
running for each event. 

Batch requests that come into Tyk are *run through the whole tyk machinery* and *use a relative path to prevent spamming*, this means that a batch request to 
Tyk for three resources with the same API key will have three requests applied to their session quota and request limiting could become active if they are being throttled.

Tyk reconstructs the API request based on the data in the batch request, this is to ensure that Tyk is not being used to proxy requests to other hosts outside of the upstream
API being accessed.

Batch requests are created by POSTing to the /{api-id}/tyk/batch endpoint, these requests **do not require a valid key**, but their request list does, 
here is a sample request body:

    {
        "requests": [
            {
                "method": "GET",
                "headers": {
                    "x-tyk-test": "1",
                    "x-tyk-version": "1.2",
                    "authorization": "1dbc83b9c431649d7698faa9797e2900f"
                },
                "body": "",
                "relative_url": "get"
            },
            {
                "method": "GET",
                "headers": {
                    "x-tyk-test": "2",
                    "x-tyk-version": "1.2",
                    "authorization": "1dbc83b9c431649d7698faa9797e2900f"
                },
                "body": "",
                "relative_url": "get"
            }
        ],
        "suppress_parallel_execution": false
    }

the response will will be a structured reply that encapsulates the responses for each of the outbound requests. If `suppress_parallel_execution` is set to `true`, 
requests will be made synchronously, if set to `false` then they will run in parallel and the response order is not guaranteed.

A response to the above when pointing at the httpbin(1) would look like:

    [
        {
            "relative_url": "get",
            "code": 200,
            "headers": {
                "Access-Control-Allow-Credentials": [
                    "true"
                ],
                "Access-Control-Allow-Origin": [
                    "*"
                ],
                "Content-Length": [
                    "497"
                ],
                "Content-Type": [
                    "application/json"
                ],
                "Date": [
                    "Wed, 12 Nov 2014 15:32:43 GMT"
                ],
                "Server": [
                    "gunicorn/18.0"
                ],
                "Via": [
                    "1.1 vegur"
                ]
            },
            "body": "{\n  \"args\": {}, \n  \"headers\": {\n    \"Accept-Encoding\": \"gzip\", \n    \"Authorization\": \"1dbc83b9c431649d7698faa9797e2900f\", \n    \"Connect-Time\": \"2\", \n    \"Connection\": \"close\", \n    \"Host\": \"httpbin.org\", \n    \"Total-Route-Time\": \"0\", \n    \"User-Agent\": \"Go 1.1 package http\", \n    \"Via\": \"1.1 vegur\", \n    \"X-Request-Id\": \"6a22499a-2776-4aa1-80c0-686581a8be4d\", \n    \"X-Tyk-Test\": \"2\", \n    \"X-Tyk-Version\": \"1.2\"\n  }, \n  \"origin\": \"127.0.0.1, 62.232.114.250\", \n  \"url\": \"http://httpbin.org/get\"\n}"
        },
        {
            "relative_url": "get",
            "code": 200,
            "headers": {
                "Access-Control-Allow-Credentials": [
                    "true"
                ],
                "Access-Control-Allow-Origin": [
                    "*"
                ],
                "Content-Length": [
                    "497"
                ],
                "Content-Type": [
                    "application/json"
                ],
                "Date": [
                    "Wed, 12 Nov 2014 15:32:43 GMT"
                ],
                "Server": [
                    "gunicorn/18.0"
                ],
                "Via": [
                    "1.1 vegur"
                ]
            },
            "body": "{\n  \"args\": {}, \n  \"headers\": {\n    \"Accept-Encoding\": \"gzip\", \n    \"Authorization\": \"1dbc83b9c431649d7698faa9797e2900f\", \n    \"Connect-Time\": \"7\", \n    \"Connection\": \"close\", \n    \"Host\": \"httpbin.org\", \n    \"Total-Route-Time\": \"0\", \n    \"User-Agent\": \"Go 1.1 package http\", \n    \"Via\": \"1.1 vegur\", \n    \"X-Request-Id\": \"1ab61f50-51ff-4828-a7e2-17240385a6d2\", \n    \"X-Tyk-Test\": \"1\", \n    \"X-Tyk-Version\": \"1.2\"\n  }, \n  \"origin\": \"127.0.0.1, 62.232.114.250\", \n  \"url\": \"http://httpbin.org/get\"\n}"
        }
    ]

With the body for each request string encoded in the `body` field.